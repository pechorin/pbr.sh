#!/usr/bin/env bash

# TODO:
# - multiple backup repo targets
# - echo to stdout for all backup/restore logs
# - restore from local machine?
# - протестировать когда функция упала, нужно нормально обработать эту ситуацию и уведомить в телегу

set -e

echo "Running backup script"

# TODO: or use value from $1 ?
source ~/.config/.secrets/settings.conf

# Markers for removing unnecessary lines from logs (for notifications)
backup_log_start_pattern="using parent|start scan"

# Check for required toolset
test -n "$(command -v restic)" || { echo "restic missing" && exit 1; }
test -n "$(command -v curl)"   || { echo "curl missing" && exit 1; }

# $1 -> repository name
function init_backup_repository! {
  # if repo not exists
  if ! restic --password-file=<(echo $backup_storage_password) --repo="$1" cat config > /dev/null; then
    # then init new one
    restic --password-file=<(echo $backup_storage_password) --repo="$1" init
  fi
}

# $1 -> bold title message
# $2 -> log message
function notify_to_telegram {
  if [ -z "$1" ] || [ -z "$2" ] || [ -z "$telegram_bot_token" ] || [ -z "$telegram_chat_id" ]; then
    echo "skipping telegram notifications"
    return 0
  fi

  local text="<b>$1</b>\n$2"
  local message_json="{\"chat_id\": $telegram_chat_id, \"text\": \"$text\", \"parse_mode\": \"html\", \"disable_notification\": true}"


  curl -X POST \
       -H 'Content-Type: application/json' \
       -d "$message_json" \
       https://api.telegram.org/bot${telegram_bot_token}/sendMessage
}

# Convert "a,b" string to list
# "a, b,c" => a b c
# "a,   b" => a b
split_by_comma () {
  [ -z "$1" ] && return 1;

  local volumes=()

  OLD_IFS="$IFS"; IFS=','
  for v in $1; do
    volume_name=$(echo "$v" | sed 's/ //g') # remove spaces around
    volumes+=("$volume_name")
  done
  IFS="$OLD_IFS"

  echo ${volumes[@]}
  return 0
}

# Make directories argument list
# convert "a,b" to
#   /a /b
#
# if --with-path-glob-ending provided in $2 then convert to:
#   /a/* /b/*
volumes_string_to_mounted_dir_list () {
  [ -z "$1" ] && return 1;

  local dir_list=()
  for v in $(split_by_comma "$1"); do
    if [ "$2" == "--with-path-glob-ending" ]; then
      dir_list+=("/$v/*")
    else
      dir_list+=("/$v")
    fi
  done

  echo ${dir_list[@]}
  return 0
}

# Make docker volumes mount argument list
# convert from "a,b" to
#   -v a:/a/ -v b:/b/
# if --readonly provided in $2 then convert to:
#   -v a:/a/:ro -v b:/b/:ro
volumes_string_to_docker_volumes_arg () {
  [ -z "$1" ] && return 1;

  local args_list=()
  for v in $(split_by_comma "$1"); do
    args_list+=("-v")

    if [ "$2" = "--readonly" ]; then
      args_list+=("$v:/$v/:ro")
    else
      args_list+=("$v:/$v/")
    fi
  done

  echo ${args_list[@]}
  return 0
}

function do_volumes_backup! {
  if [ -z "$backup_docker_volumes" ] && [ -z "$volumes_rclone_repo" ]; then
    echo "Skipping volumes backup"
    return 0
  fi

  init_backup_repository! "$volumes_rclone_repo"

  # Bakcup command will run in container:
  backup_command="restic -v --password-file=<(echo \$backup_storage_password) \
                            --host=\$backup_name \
                            --repo=\$volumes_rclone_repo backup \
                            $(volumes_string_to_mounted_dir_list $backup_docker_volumes)"

  # Run backup inside container
  # - mount backup volumes
  # - mount rclone config
  # - mount backup settings
  # - run backup inside alpine container, but use bash instead of ash internally
  #   because we need bash process substituion <() for safety providing password to processes
  backup_log=$(docker run --rm --name "volumes_backup" \
    $(volumes_string_to_docker_volumes_arg $backup_docker_volumes --readonly) \
    -v "$(realpath ~/.config/rclone/rclone.conf):/root/.config/rclone/rclone.conf:ro" \
    -v "$(realpath ~/.config/.secrets/settings.conf):/settings.conf:ro" \
    alpine:latest /bin/ash -e -c "
      apk update && apk add rclone restic bash
      source ./settings.conf
      bash -c \"$backup_command\"
  ")

  # remove unnecessary data from telegram message and notify
  filtered_log=$(echo "$backup_log" | sed -n -E -e "/$backup_log_start_pattern/,\$p")
  notify_to_telegram "$backup_name volumes backup" "$filtered_log"

  return 0
}

function do_volumes_restore! {
  if [ -z "$backup_docker_volumes" ] && [ -z "$volumes_rclone_repo" ]; then
    echo "Skipping docker volumes restore"
    return 0
  fi

  restore_folder="./restore"

  [ -d $restore_folder ] && rm -r $restore_folder      # ensure no restore folder present
  mkdir $restore_folder                                # create new one
  restore_folder_abs_path=$(realpath $restore_folder)  # construct absolute path

  # Make this configurable?
  restic --password-file=<(echo $backup_storage_password) -v --repo="$volumes_rclone_repo" check

  # Do restore on host folder
  restic --password-file=<(echo $backup_storage_password) -v --repo="$volumes_rclone_repo" restore latest \
         --target="$restore_folder_abs_path"


  # Mount restore folder and docker volumes in container, and then do restoration
  restore_log=$(docker run --rm --name "restore" \
    $(volumes_string_to_docker_volumes_arg $backup_docker_volumes) \
    -v "$restore_folder_abs_path:/restore/" \
    alpine:latest /bin/ash -e -c "
      rm -rf $(volumes_string_to_mounted_dir_list $backup_docker_volumes --with-path-glob-ending)
      for v in $(split_by_comma $backup_docker_volumes); do
        cp -r /restore/\${v}/* /\${v}/
      done
  ")

  # Count restored size and remove restore folder
  restored_size=($(du -sh $restore_folder))
  rm -r $restore_folder

  notify_to_telegram "Restoring $backup_name volumes backup" "total size: ${restored_size[0]}"

  return 0
}

function do_db_backup! {
  if [ -z "$db_rclone_repo" ]; then
    echo "Skipping db backup"
    return 0
  fi

  init_backup_repository! "$db_rclone_repo"

  dumps=()
  remove_local_config () { rm -f ./backup.cnf; }
  remove_docker_config () { docker exec $mysql_id sh -e -c "rm -f /backup.cnf"; }

  if [ -n "$docker_mysql_db_names" ]; then
    # Fetch mysql container
    mysql_id=$(docker ps --filter "ancestor=mysql" -q)
    [ -n "$mysql_id" ] || { echo "mysql not running, aborting backup" && exit 1; }

    # Copy password file to mysql container
    echo -e "[mysqldump]\nuser=$docker_mysql_user\npassword=$docker_mysql_password" > ./backup.cnf
    if ! docker cp ./backup.cnf ${mysql_id}:/backup.cnf; then
      # ensure password file will be removed in any conditions
      echo "docker cp failed"
      remove_local_config
      return 1
    else
      remove_local_config
    fi

    # Run backup
    # also ensure what config file removed fron container
    docker exec $mysql_id sh -e -c "
      mysqldump --defaults-extra-file=/backup.cnf --add-drop-database \
                --databases $(split_by_comma $docker_mysql_db_names)" > ./docker_mysql_dump.sql || \
    { remove_docker_config; echo "mysql dump failed"; return 1; }

    dumps+=($(realpath ./docker_mysql_dump.sql))

    # Remove password config file from container
    remove_docker_config
  fi

  if [ -n "$host_postgresql_db_names" ]; then
    for db in $(split_by_comma $host_postgresql_db_names); do
      pg_dump --clean $db > ./host_postgresql_${db}_dump.sql
      dumps+=($(realpath ./host_postgresql_${db}_dump.sql))
    done
  fi

  backup_log=$(restic -v --password-file=<(echo $backup_storage_password) \
                         --host=$backup_name \
                         --repo=$db_rclone_repo backup ${dumps[@]}) || \
  { rm -rf ${dumps[@]}; echo "db backup failed"; return 1; }

  # Cleanup
  rm -rf ${dumps[@]}

  # remove unnecessary data from telegram message and notify
  filtered_log=$(echo "$backup_log" | sed -n -E -e "/$backup_log_start_pattern/,\$p")
  notify_to_telegram "$backup_name DB backup" "$filtered_log"

  return 0
}

# Execution part
if [ "$1" = "restore" ]; then
  do_volumes_restore!

  echo -e "\nRestore complete"
else
  do_volumes_backup!
  do_db_backup!

  echo -e "\nBackup complete"
fi
