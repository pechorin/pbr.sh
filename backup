#!/usr/bin/env bash

# TODO:
# - multiple backup repo targets
# - echo to stdout for all backup/restore logs
# - restore from local machine?
# - протестировать когда функция упала, нужно нормально обработать эту ситуацию и уведомить в телегу
# - remove copy-paste from restore functions

set -e

echo "Running pbr.sh"

# TODO: or use value from $1 ?
source ~/.config/.secrets/settings.conf

# internal variables
backup_log_start_pattern="using parent|start scan" # Markers for removing unnecessary lines from logs (for notifications)
log_file_path="./pbr_log.txt"
log_separator="--------------------"
mysql_credentials_config_name="backup.cnf"
mysql_backup_file_name="docker_mysql_dump.sql"

# Check for required toolset
test -n "$(command -v restic)" || { echo "restic missing" && exit 1; }
test -n "$(command -v curl)"   || { echo "curl missing" && exit 1; }

# $1 -> repository name
function init_backup_repository! {
  # if repo not exists
  if ! restic --password-file=<(echo $backup_storage_password) --repo="$1" cat config > /dev/null; then
    # then init new one
    restic --password-file=<(echo $backup_storage_password) --repo="$1" init
  fi
}

# $1 -> bold title message
# $2 -> log message
function notify_to_telegram {
  if [ -z "$1" ] || [ -z "$2" ] || [ -z "$telegram_bot_token" ] || [ -z "$telegram_chat_id" ]; then
    echo "skipping telegram notifications"
    return 0
  fi

  local text="<b>$1</b>\n$2"
  local message_json="{\"chat_id\": $telegram_chat_id, \"text\": \"$text\", \"parse_mode\": \"html\", \"disable_notification\": true}"


  curl -X POST \
       -H 'Content-Type: application/json' \
       -d "$message_json" \
       https://api.telegram.org/bot${telegram_bot_token}/sendMessage
}

# Convert "a,b" string to list
# "a, b,c" => a b c
# "a,   b" => a b
split_by_comma () {
  [ -z "$1" ] && return 1;

  local volumes=()

  OLD_IFS="$IFS"; IFS=','
  for v in $1; do
    volume_name=$(echo "$v" | sed 's/ //g') # remove spaces around
    volumes+=("$volume_name")
  done
  IFS="$OLD_IFS"

  echo ${volumes[@]}
  return 0
}

# Make directories argument list
# convert "a,b" to
#   /a /b
#
# if --with-path-glob-ending provided in $2 then convert to:
#   /a/* /b/*
volumes_string_to_mounted_dir_list () {
  [ -z "$1" ] && return 1;

  local dir_list=()
  for v in $(split_by_comma "$1"); do
    if [ "$2" == "--with-path-glob-ending" ]; then
      dir_list+=("/$v/*")
    else
      dir_list+=("/$v")
    fi
  done

  echo ${dir_list[@]}
  return 0
}

# Make docker volumes mount argument list
# convert from "a,b" to
#   -v a:/a/ -v b:/b/
# if --readonly provided in $2 then convert to:
#   -v a:/a/:ro -v b:/b/:ro
volumes_string_to_docker_volumes_arg () {
  [ -z "$1" ] && return 1;

  local args_list=()
  for v in $(split_by_comma "$1"); do
    args_list+=("-v")

    if [ "$2" = "--readonly" ]; then
      args_list+=("$v:/$v/:ro")
    else
      args_list+=("$v:/$v/")
    fi
  done

  echo ${args_list[@]}
  return 0
}

# Remove old restore folder is exists
# Create new one and return absolute path via stdin
prepare_restore_folder () {
  restore_folder="./restore"

  [ -d $restore_folder ] && rm -r $restore_folder      # ensure no restore folder present
  mkdir $restore_folder                                # create new one
  restore_folder_abs_path=$(realpath $restore_folder)  # construct absolute path

  echo $restore_folder_abs_path

  return 0
}

get_mysql_container_id () {
  mysql_id=$(docker ps --filter "ancestor=mysql" -q)
  [ -n "$mysql_id" ] || { echo "mysql not running, aborting backup" && return 1; }

  echo $mysql_id
}

# Create config file suitable for mysql
# Copy this file to container
#
#
# $1 -> mysql container id
#
# NOTICE: config file should be deleted after with remove_mysql_credentials_from_container
copy_mysql_credentials_to_container () {
  [ -z "$1" ] && { echo "mysql container id missing" && return 1; }

  # Copy password file to mysql container
  echo -e "[mysqldump]\nuser=$docker_mysql_user\npassword=$docker_mysql_password" > ./${mysql_credentials_config_name}

  if ! docker cp ./${mysql_credentials_config_name} ${1}:/${mysql_credentials_config_name}; then
    # ensure password file will be removed in any conditions
    echo "docker cp failed"
    rm -f ./${mysql_credentials_config_name}
    return 1
  else
    rm -f ./${mysql_credentials_config_name}
    return 0
  fi
}

# $1 -> mysql container id
remove_mysql_credentials_from_container () {
  docker exec $1 sh -e -c "rm -f /${mysql_credentials_config_name}"; }
}

function do_volumes_backup! {
  if [ -z "$backup_docker_volumes" ] && [ -z "$volumes_rclone_repo" ]; then
    echo "Skipping volumes backup"
    return 0
  fi

  init_backup_repository! "$volumes_rclone_repo"

  # Bakcup command will run in container:
  backup_command="restic -v --password-file=<(echo \$backup_storage_password) \
                            --host=\$backup_name \
                            --repo=\$volumes_rclone_repo backup \
                            $(volumes_string_to_mounted_dir_list $backup_docker_volumes)"

  # Run backup inside container
  # - mount backup volumes
  # - mount rclone config
  # - mount backup settings
  # - run backup inside alpine container, but use bash instead of ash internally
  #   because we need bash process substituion <() for safety providing password to processes
  backup_log=$(docker run --rm --name "volumes_backup" \
    $(volumes_string_to_docker_volumes_arg $backup_docker_volumes --readonly) \
    -v "$(realpath ~/.config/rclone/rclone.conf):/root/.config/rclone/rclone.conf:ro" \
    -v "$(realpath ~/.config/.secrets/settings.conf):/settings.conf:ro" \
    alpine:latest /bin/ash -e -c "
      apk update && apk add rclone restic bash
      source ./settings.conf
      bash -c \"$backup_command\"
  ")

  # Log to stdout
  printf "$backup_log\n"

  # remove unnecessary data from telegram message and notify
  filtered_log=$(echo "$backup_log" | sed -n -E -e "/$backup_log_start_pattern/,\$p")
  notify_to_telegram "$backup_name volumes backup" "$filtered_log"

  return 0
}

function do_volumes_restore! {
  if [ -z "$backup_docker_volumes" ] && [ -z "$volumes_rclone_repo" ]; then
    echo "Skipping docker volumes restore"
    return 0
  fi

  restore_folder_path=$(prepare_restore_folder)

  # Make this configurable?
  restic --password-file=<(echo $backup_storage_password) -v --repo="$volumes_rclone_repo" check

  # Do restore on host folder
  restic --password-file=<(echo $backup_storage_password) -v --repo="$volumes_rclone_repo" restore \
           latest --target="$restore_folder_path"


  # Mount restore folder and docker volumes in container, and then do restoration
  restore_log=$(docker run --rm --name "restore" \
    $(volumes_string_to_docker_volumes_arg $backup_docker_volumes) \
    -v "$restore_folder_abs_path:/restore/" \
    alpine:latest /bin/ash -e -c "
      rm -rf $(volumes_string_to_mounted_dir_list $backup_docker_volumes --with-path-glob-ending)
      for v in $(split_by_comma $backup_docker_volumes); do
        cp -r /restore/\${v}/* /\${v}/
      done
  ")

  # Log to stdout
  printf "$restore_log\n"

  # Count restored size and remove restore folder
  restored_size=($(du -sh $restore_folder_path))
  rm -r $restore_folder_path

  notify_to_telegram "Restoring $backup_name volumes backup" "total size: ${restored_size[0]}"

  return 0
}

function do_db_backup! {
  if [ -z "$db_rclone_repo" ]; then
    echo "Skipping db backup"
    return 0
  fi

  init_backup_repository! "$db_rclone_repo"

  dumps=()

  # Mysql docker backup
  if [ -n "$docker_mysql_db_names" ]; then
    mysql_id=$(get_mysql_container_id)
    copy_mysql_credentials_to_container $mysql_id

    # Run backup
    # also ensure what config file removed fron container
    docker exec $mysql_id sh -e -c "
      mysqldump --defaults-extra-file=/${mysql_credentials_config_name} --add-drop-database \
                --databases $(split_by_comma $docker_mysql_db_names)" > ./${mysql_backup_file_name} || \
    { remove_mysql_credentials_from_container $mysql_id ; echo "mysql dump failed"; return 1; }

    dumps+=($mysql_backup_file_name)

    remove_mysql_credentials_from_container $mysql_id
  fi

  # Postgresql docker backup
  if [ -n "$host_postgresql_db_names" ]; then
    for db in $(split_by_comma $host_postgresql_db_names); do
      pg_dump --clean $db > ./host_postgresql_${db}_dump.sql
      dumps+=(host_postgresql_${db}_dump.sql)
    done
  fi

  # if no backups was processed then return
  [ 0 -eq ${#dumps[@]} ] && return 0;

  # otherwise do backup
  backup_log=$(restic -v --password-file=<(echo $backup_storage_password) \
                         --host=$backup_name \
                         --repo=$db_rclone_repo backup ${dumps[@]}) || \
  { rm -rf ${dumps[@]}; echo "db backup failed"; return 1; }

  # Cleanup
  rm -rf ${dumps[@]}

  # Log to stdout
  printf "$backup_log\n"

  # remove unnecessary data from telegram message and notify
  filtered_log=$(echo "$backup_log" | sed -n -E -e "/$backup_log_start_pattern/,\$p")
  notify_to_telegram "$backup_name DB backup" "$filtered_log"

  return 0
}

function do_db_restore! {
  if [ -z "$db_rclone_repo" ]; then
    echo "Skipping db restore"
    return 0
  fi

  restore_folder_path=$(prepare_restore_folder)

  # Make this configurable?
  restic --password-file=<(echo $backup_storage_password) -v --repo="$db_rclone_repo" check

  # Do restore on host folder
  restic --password-file=<(echo $backup_storage_password) -v --repo="$db_rclone_repo" restore latest \
         --target="$restore_folder_path"

  if [ -n "$docker_mysql_db_names" ]; then
    mysql_id=$(get_mysql_container_id)
    copy_mysql_credentials_to_container $mysql_id

    # Run restore
    # also ensure what config file removed fron container
    docker exec -i $mysql_id sh -c "mysql --defaults-extra-file=/${mysql_credentials_config_name}" \
      < ${restore_folder_path}/${mysql_backup_file_name} || \
      { remove_mysql_credentials_from_container $mysql_id ; echo "mysql restore failed"; return 1 }

    remove_mysql_credentials_from_container $mysql_id
  fi

  if [ -n "$host_postgresql_db_names" ]; then
    for db in $(split_by_comma $host_postgresql_db_names); do
      psql $db < ${restore_folder_path}/host_postgresql_${db}_dump.sql
    done
  fi

  restored_size=($(du -sh $restore_folder_path))
  rm -rf $restore_folder_path

  notify_to_telegram "Restoring $backup_name db backup" "total size: ${restored_size[0]}"
}

# Execution part
run!() {
  echo -e "\n$log_separator"

  if [ "$1" = "restore" ]; then
    echo "Starting restore at $(date)"

    do_volumes_restore!
    do_db_restore!

    echo -e "\nRestore complete"
  else
    echo "Starting backup at $(date)"

    do_volumes_backup!
    do_db_backup!

    echo -e "\nBackup complete"
  fi
}

run! $1 &>> $log_file_path || {
  if [ "$1" = "restore" ]; then
    failed_part="Restore"
  else
    failed_part="Backup"
  fi

  notify_to_telegram "$failed_part script failed", "inspect errors in $log_file_path"
}

echo "pbr.sh finished, log can be found in $log_file_path"
